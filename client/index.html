<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASU Engineering RAG Assistant</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Plus+Jakarta+Sans:wght@400;500;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=12">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .chunk-used {
            border: 2px solid var(--accent-color, #00A3E0) !important;
            background-color: rgba(0, 163, 224, 0.05) !important;
            position: relative;
        }

        .chunk-used::after {
            content: "Used in Answer";
            position: absolute;
            top: -10px;
            right: 10px;
            background: var(--accent-color, #00A3E0);
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        .citation-link {
            cursor: pointer;
            color: var(--primary-color, #8C1D40);
            text-decoration: underline;
            font-weight: 500;
        }

        .source-badge {
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="icon">ðŸ¤–</div>
                <h1>ASU <span>RAG</span></h1>
                <button id="close-sidebar" class="mobile-only-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <nav class="nav-links">
                <div class="nav-item active" onclick="switchView('view-chat', this)">
                    <i class="fas fa-comment-dots"></i>
                    <span>Chat Assistant</span>
                </div>
                <div class="nav-item" onclick="switchView('view-pdf', this)">
                    <i class="fas fa-file-alt"></i>
                    <span>Documents</span>
                </div>
                <div class="nav-item" onclick="switchView('view-web', this)">
                    <i class="fas fa-globe"></i>
                    <span>Web Content</span>
                </div>
                <div class="nav-item" onclick="switchView('view-db', this)">
                    <i class="fas fa-database"></i>
                    <span>SQL Databases</span>
                </div>
                <div class="nav-item" onclick="switchView('view-manage', this)">
                    <i class="fas fa-tasks"></i>
                    <span>Management</span>
                </div>
                <div class="nav-item" onclick="switchView('view-settings', this)">
                    <i class="fas fa-cog"></i>
                    <span>Settings</span>
                </div>
            </nav>

            <div class="sidebar-footer">
                <div class="disclaimer">
                    Powered by ASU Engineering
                </div>
            </div>
        </aside>

        <!-- Main Chat Area -->
        <main class="main-content">
            <header>
                <div class="status-indicator">
                    <button id="menu-toggle" class="mobile-only-btn">
                        <i class="fas fa-bars"></i>
                    </button>
                    <span class="status-dot"></span>
                    <span class="status-text">Connected</span>
                </div>
                <div class="header-actions">
                    <button id="db-btn" class="icon-btn" title="Database Management">
                        <i class="fas fa-server"></i>
                    </button>
                    <button id="settings-btn" class="icon-btn" title="Settings">
                        <i class="fas fa-sliders-h"></i>
                    </button>
                </div>
            </header>

            <!-- View: Chat Assistant -->
            <div id="view-chat" class="view-section active">
                <div class="chat-container" id="chat-container">
                    <div class="welcome-message">
                        <h2>Hello, <span>How can I help you?</span></h2>
                        <p>Access your documents through natural language. Ask specific questions or explore topics.</p>
                        <div class="suggested-queries">
                            <button onclick="setQuery('What are the available departments?')">Departments</button>
                            <button onclick="setQuery('Tell me about the bylaws.')">Bylaws</button>
                            <button onclick="setQuery('How to apply for graduation?')">Graduation</button>
                        </div>
                    </div>
                </div>

                <div class="input-area-wrapper">
                    <div class="input-container">
                        <div class="mode-dropdown-container">
                            <select id="chat-mode" class="mode-select-compact">
                                <option value="normal">ðŸ”˜ Normal</option>
                                <option value="deep">ðŸ§  Deep Thinking</option>
                            </select>
                        </div>
                        <textarea id="user-input" placeholder="Message RAG Assistant..." rows="1"></textarea>

                        <div class="voice-controls"
                            style="margin-right: 8px; display: flex; align-items: center; gap: 5px;">
                            <!-- Language selector removed -->
                            <button id="mic-btn" class="icon-btn" title="Speak" style="width: 32px; height: 32px;">
                                <i class="fas fa-microphone"></i>
                            </button>
                        </div>

                        <button id="send-btn">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- View: PDF Documents -->
            <div id="view-pdf" class="view-section">
                <div class="section-container">
                    <div class="db-section">
                        <h3><i class="fas fa-file-alt"></i> Document Management</h3>
                        <div class="upload-zone" id="upload-zone">
                            <input type="file" id="file-input" accept=".pdf,.docx,.txt,.csv,.md,.xlsx,.xls" hidden>
                            <p><i class="fas fa-cloud-upload-alt"></i> Drag & Drop files here or <a href="#"
                                    id="browse-btn">Browse</a></p>
                            <span id="file-name-display"></span>
                        </div>
                        <p class="hint" style="text-align: center; margin-top: 8px;">
                            Supported formats: <strong>PDF, DOCX, TXT, MD, CSV, XLSX, XLS</strong>
                        </p>
                        <div class="pdf-controls-row">
                            <button id="upload-btn" class="action-btn" disabled>Upload File</button>
                            <button id="stream-btn" class="action-btn warning-btn">
                                <i class="fas fa-sync"></i> Quick Sync
                            </button>
                            <button id="fresh-stream-btn" class="action-btn danger-btn">
                                <i class="fas fa-hammer"></i> Fresh Build
                            </button>
                        </div>
                    </div>

                    <div class="db-section">
                        <h3><i class="fas fa-terminal"></i> Ingestion Logs</h3>
                        <div id="pdf-console" class="mini-terminal">
                            <span class="log-line system">> Document synchronization updates appear here.</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- View: Web Content -->
            <div id="view-web" class="view-section">
                <div class="section-container">
                    <div class="db-section">
                        <h3><i class="fas fa-globe"></i> Web Ingestion</h3>
                        <p class="section-desc">Crawl website content to expand knowledge.</p>
                        <div class="url-input-group">
                            <input type="text" id="web-url-input" placeholder="https://example.com/about">
                            <button id="web-ingest-btn" class="action-btn">
                                <i class="fas fa-spider"></i> Crawl & Ingest
                            </button>
                        </div>
                    </div>

                    <div class="db-section">
                        <h3><i class="fas fa-terminal"></i> Crawler Logs</h3>
                        <div id="web-console" class="mini-terminal">
                            <span class="log-line system">> Web crawling progress appear here.</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- View: SQL Databases -->
            <div id="view-db" class="view-section">
                <div class="section-container">
                    <div class="db-section">
                        <h3><i class="fas fa-database"></i> SQL Database Ingestion</h3>
                        <div class="db-resource-group">
                            <div class="field-row">
                                <label>Schema:</label>
                                <select id="db-schema-select">
                                    <option value="">Default / Loading...</option>
                                </select>
                            </div>
                            <div class="field-row">
                                <label>Tables:</label>
                                <div id="db-tables-container">
                                    <p class="hint">Select schema to load tables...</p>
                                </div>
                            </div>
                            <button id="db-ingest-btn" class="action-btn">
                                <i class="fas fa-database"></i> Ingest Selected Tables
                            </button>
                        </div>
                    </div>
                    <div class="db-section">
                        <h3><i class="fas fa-terminal"></i> Database Ingestion Logs</h3>
                        <div id="db-console" class="mini-terminal">
                            <span class="log-line system">> DB table ingestion updates appear here.</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- View: Management -->
            <div id="view-manage" class="view-section">
                <div class="section-container">
                    <div class="db-section">
                        <h3><i class="fas fa-tasks"></i> Managed Resources</h3>
                        <div id="resource-list-container" class="resource-management-list">
                            <p class="hint">Loading managed resources...</p>
                        </div>
                    </div>

                    <div class="db-section">
                        <h3><i class="fas fa-heartbeat"></i> Index Health</h3>
                        <div class="health-container">
                            <div class="health-header">
                                <div class="health-stat">
                                    <span class="label">Total Documents</span>
                                    <span class="value" id="health-total-docs">-</span>
                                </div>
                                <div class="health-stat">
                                    <span class="label">Total Chunks</span>
                                    <span class="value" id="health-total-chunks">-</span>
                                </div>
                                <button id="sync-btn" class="action-btn warning-btn">
                                    <i class="fas fa-sync-alt"></i> Sync Missing
                                </button>
                            </div>

                            <div class="health-list-header">
                                <span>Source Name</span>
                                <span>Status</span>
                                <span>Chunks</span>
                            </div>
                            <div id="health-list" class="health-list">
                                <!-- Health items -->
                                <p class="hint">Checking index...</p>
                            </div>
                        </div>
                    </div>

                    <div class="db-section">
                        <h3><i class="fas fa-exclamation-triangle"></i> System Operations</h3>
                        <div class="danger-zone">
                            <button id="reset-all-btn" class="action-btn delete-btn-full">
                                <i class="fas fa-trash-alt"></i> Wipe All Data & Reset
                            </button>
                        </div>
                    </div>

                    <div class="db-section">
                        <h3><i class="fas fa-terminal"></i> System Logs</h3>
                        <div id="console-output" class="terminal-window">
                            <span class="log-line system">> View live ingestion logs here.</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- View: Settings -->
            <div id="view-settings" class="view-section">
                <div class="section-container">
                    <div class="db-section">
                        <h3><i class="fas fa-cog"></i> Global Settings</h3>

                        <div class="setting-group">
                            <label for="provider-select">LLM Provider</label>
                            <select id="provider-select">
                                <option value="openai">OpenAI</option>
                                <option value="gemini">Google Gemini</option>
                                <option value="ollama">Ollama (Local)</option>
                                <option value="vllm">vLLM (Local)</option>
                            </select>
                        </div>

                        <div class="setting-group">
                            <label for="embedding-provider-select">Embedding Provider</label>
                            <select id="embedding-provider-select">
                                <option value="openai">OpenAI</option>
                                <option value="ollama">Ollama (Local)</option>
                                <option value="vllm">vLLM (Local)</option>
                            </select>
                        </div>

                        <div id="local-settings" class="provider-settings-group" style="display: none;">
                            <div class="setting-group" id="vllm-url-group" style="display: none;">
                                <label for="vllm-url">Provider Base URL (vLLM)</label>
                                <input type="text" id="vllm-url" placeholder="http://localhost:9090/v1">
                            </div>
                            <div class="setting-group" id="llm-model-group">
                                <label for="model-select">LLM Model</label>
                                <select id="model-select">
                                    <option value="" disabled selected>Select a model...</option>
                                </select>
                            </div>
                            <div class="setting-group" id="embedding-model-group">
                                <label for="embedding-model-select">Embedding Model</label>
                                <select id="embedding-model-select">
                                    <option value="" disabled selected>Select a model...</option>
                                </select>
                            </div>
                            <p id="model-hint" class="setting-hint"></p>
                        </div>

                        <div id="cloud-settings" class="provider-settings-group" style="display: none;">
                            <div class="setting-group" id="openai-key-group">
                                <label for="openai-api-key">OpenAI API Key</label>
                                <input type="password" id="openai-api-key" placeholder="sk-...">
                            </div>
                            <div class="setting-group" id="openai-url-group">
                                <label for="openai-base-url">OpenAI Base URL</label>
                                <input type="text" id="openai-base-url" placeholder="https://api.openai.com/v1">
                            </div>
                            <div class="setting-group" id="gemini-key-group">
                                <label for="gemini-api-key">Gemini API Key</label>
                                <input type="password" id="gemini-api-key" placeholder="AIza...">
                            </div>
                        </div>

                        <button id="save-settings-btn" class="primary-btn" style="margin-top: 20px;">Save
                            Changes</button>
                    </div>
                </div>
            </div>
        </main>

    </div>

    <div id="toast" class="toast">
        <i class="fas fa-check-circle"></i>
        <span id="toast-message">Settings saved successfully</span>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        // Dynamically get the API base URL from the current window location
        const API_BASE = window.location.origin;

        function setQuery(query) {
            userInput.value = query;
            sendMessage();
        }

        function switchView(viewId, navItem) {
            // Hide all views
            document.querySelectorAll('.view-section').forEach(view => {
                view.classList.remove('active');
            });
            // Show selected view
            const activeView = document.getElementById(viewId);
            if (activeView) activeView.classList.add('active');

            // Update sidebar active state
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            if (navItem) navItem.classList.add('active');

            // Trigger data fetching if needed
            if (viewId === 'view-manage') loadResources();
            if (viewId === 'view-db') {
                loadSchemas();
                // loadTables(""); // Wait for user selection
            }

            // Close sidebar on mobile after selection
            if (window.innerWidth <= 768) {
                document.querySelector('.sidebar').classList.remove('active');
            }

            // Log view change
            console.log(`Switched to view: ${viewId}`);
        }

        // Helper function to detect text direction based on language
        function detectLanguageDirection(text) {
            // Check if text contains Arabic characters
            const arabicPattern = /[\u0600-\u06FF]/;
            return arabicPattern.test(text) ? 'rtl' : 'ltr';
        }

        function addMessage(content, isUser = false) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;

            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.innerText = isUser ? 'ðŸ‘¤' : 'AI';

            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            textDiv.innerText = content;

            // Auto-detect and set text direction
            if (content) {
                textDiv.dir = detectLanguageDirection(content);
            }

            msgDiv.appendChild(avatar);
            msgDiv.appendChild(textDiv);
            chatContainer.appendChild(msgDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return textDiv;
        }

        async function sendMessage(isContinuation = false) {
            const question = isContinuation ? lastUserQuestion : userInput.value.trim();
            const chatMode = document.getElementById('chat-mode').value;
            const isDeepThinking = chatMode === 'deep';

            if (!question) return;

            if (!isContinuation) {
                lastUserQuestion = question;
                userInput.value = '';
                userInput.dir = 'ltr'; // Reset to LTR after sending
                addMessage(question, true);
            } else {
                // For continuation, add a system-like hint to the UI or just start bot message
                addMessage("Continuing response...", true);
            }

            const botMsgDiv = addMessage('', false);
            // Create separate containers for content and metadata
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = '<div class="typing">AI Assistant is thinking...</div>';

            const metaContainerDiv = document.createElement('div');
            metaContainerDiv.className = 'message-meta-container';

            botMsgDiv.innerHTML = '';
            botMsgDiv.appendChild(contentDiv);
            botMsgDiv.appendChild(metaContainerDiv);

            try {
                const url = isContinuation
                    ? `${API_BASE}/ask/stream?question=${encodeURIComponent(question)}&deep_thinking=${isDeepThinking}&is_continuation=true&last_answer=${encodeURIComponent(lastBotResponse)}`
                    : `${API_BASE}/ask/stream?question=${encodeURIComponent(question)}&deep_thinking=${isDeepThinking}`;

                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let accumulatedAnswer = '';
                let sourceMap = {};
                let usedDocs = [];

                // Clear thinking state
                contentDiv.innerHTML = '';

                let buffer = '';

                // Helper to process a single JSON line
                const processLine = (line) => {
                    if (!line.trim()) return;
                    try {
                        const data = JSON.parse(line);
                        if (data.type === 'sources') {
                            data.sources.forEach(src => {
                                const name = src.startsWith('http') ? src : src.split('/').pop();
                                sourceMap[name] = src;
                                globalResourceMap[name] = src; // Sync to global
                            });
                        } else if (data.type === 'chunk') {
                            accumulatedAnswer += data.content;

                            const renderer = new marked.Renderer();
                            renderer.text = function (token) {
                                const text = typeof token === 'string' ? token : token.text;
                                if (!text) return '';

                                return text.replace(/\[([^\]]+)\]/g, (match, content) => {
                                    const parts = content.split(',').map(s => s.trim());
                                    const possibleFile = parts[0];

                                    // Find source URL/path from map
                                    const sourcePath = sourceMap[possibleFile] || Object.values(sourceMap).find(s => s.includes(possibleFile));

                                    if (sourcePath) {
                                        const isUrl = sourcePath.startsWith('http');
                                        const safeName = possibleFile.replace(/'/g, "\\'");
                                        const icon = isUrl ? 'fa-globe' : (possibleFile.includes('Table:') ? 'fa-table' : 'fa-file-alt');
                                        const clickHandler = `previewIndexSource('${safeName}', window.currentUsedDocs || [])`;

                                        // Handle local file vs URL for direct button
                                        const openHandler = isUrl ? `window.open('${sourcePath}', '_blank')` : `window.open('${API_BASE}/files/${possibleFile}', '_blank')`;

                                        return `
                                            <span class="citation-group">
                                                <span class="citation-link" onclick="${clickHandler}" title="View Index: ${possibleFile}">
                                                    <i class="fas ${icon}"></i> ${possibleFile}
                                                </span>
                                                <button class="citation-direct-btn" onclick="${openHandler}" title="Open Original ${isUrl ? 'Website' : 'File'}">
                                                    <i class="fas fa-external-link-alt"></i>
                                                </button>
                                            </span>
                                        `;
                                    }
                                    return match;
                                });
                            };

                            contentDiv.innerHTML = marked.parse(accumulatedAnswer, { renderer });
                            chatContainer.scrollTop = chatContainer.scrollHeight;

                            if (data.type === 'done' || data.type === 'metadata') {
                                lastBotResponse = accumulatedAnswer;
                            }

                            if (data.type === 'metadata') {
                                if (data.used_docs) {
                                    usedDocs = data.used_docs;
                                    window.currentUsedDocs = usedDocs;
                                }

                                const metaDiv = document.createElement('div');
                                metaDiv.className = 'message-meta';
                                metaDiv.style.display = 'flex';

                                const stats = [
                                    { label: 'Model', value: data.model, icon: 'fa-robot' },
                                    { label: 'Total', value: data.performance.total, icon: 'fa-clock' },
                                    { label: 'LLM', value: data.performance.llm, icon: 'fa-microchip' },
                                    { label: 'Tokens', value: data.tokens, icon: 'fa-brain' }
                                ];

                                stats.forEach(stat => {
                                    const item = document.createElement('div');
                                    item.className = 'meta-item';
                                    item.innerHTML = `<i class="fas ${stat.icon}"></i> ${stat.label}: ${stat.value}`;
                                    metaDiv.appendChild(item);
                                });

                                // Add Continue Button
                                const continueBtn = document.createElement('div');
                                continueBtn.className = 'meta-item continue-btn';
                                continueBtn.style.cursor = 'pointer';
                                continueBtn.style.color = 'var(--primary-light)';
                                continueBtn.innerHTML = `<i class="fas fa-play"></i> Continue Answer`;
                                continueBtn.onclick = () => sendMessage(true);
                                metaDiv.appendChild(continueBtn);

                                if (data.sources && data.sources.length > 0) {
                                    const sourceContainer = document.createElement('div');
                                    sourceContainer.className = 'source-badges';
                                    data.sources.forEach(src => {
                                        const isUrl = src.startsWith('http');
                                        const name = isUrl ? new URL(src).hostname : src.split('/').pop();

                                        const badge = document.createElement('span');
                                        badge.className = 'source-badge';
                                        badge.onclick = () => previewIndexSource(name, usedDocs);

                                        badge.innerHTML = `<i class="fas ${isUrl ? 'fa-globe' : 'fa-file-pdf'}"></i> ${name}`;
                                        badge.title = "Click to preview source content";
                                        sourceContainer.appendChild(badge);
                                    });
                                    metaDiv.appendChild(sourceContainer);
                                }

                                metaContainerDiv.innerHTML = '';
                                metaContainerDiv.appendChild(metaDiv);
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                        } else if (data.type === 'error') {
                            contentDiv.innerText += `\nError: ${data.content}`;
                        }
                    } catch (e) {
                        console.error('Error parsing JSON chunk', e);
                    }
                };

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;

                    const lines = buffer.split('\n');
                    // Keep the last line in the buffer as it might be incomplete
                    buffer = lines.pop();

                    for (const line of lines) {
                        processLine(line);
                    }
                }

                // Process remaining buffer
                if (buffer.trim()) {
                    processLine(buffer);
                }
            } catch (error) {
                contentDiv.innerText = `Error: ${error.message}`;
            }
        }

        sendBtn.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Auto-detect text direction as user types
        userInput.addEventListener('input', (e) => {
            const text = e.target.value;
            if (text) {
                e.target.dir = detectLanguageDirection(text);
            } else {
                e.target.dir = 'ltr'; // Default to LTR when empty
            }
        });

        const providerSelect = document.getElementById('provider-select');
        const embeddingProviderSelect = document.getElementById('embedding-provider-select');
        const localSettings = document.getElementById('local-settings');
        const modelSelect = document.getElementById('model-select');
        const embeddingModelSelect = document.getElementById('embedding-model-select');
        const saveSettings = document.getElementById('save-settings-btn');
        const cloudSettings = document.getElementById('cloud-settings');
        const openaiApiKeyInput = document.getElementById('openai-api-key');
        const openaiBaseUrlInput = document.getElementById('openai-base-url');
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const vllmUrlInput = document.getElementById('vllm-url');
        const vllmUrlGroup = document.getElementById('vllm-url-group');
        const modelHint = document.getElementById('model-hint');

        // Ingestion & Control elements
        const fileInput = document.getElementById('file-input');
        const uploadZone = document.getElementById('upload-zone');
        const uploadBtn = document.getElementById('upload-btn');
        const fileNameDisplay = document.getElementById('file-name-display');
        const browseBtn = document.getElementById('browse-btn');
        const consoleOutput = document.getElementById('console-output');
        const streamBtn = document.getElementById('stream-btn');
        const freshStreamBtn = document.getElementById('fresh-stream-btn');
        const webUrlInput = document.getElementById('web-url-input');
        const webIngestBtn = document.getElementById('web-ingest-btn');
        const schemaSelect = document.getElementById('db-schema-select');
        const tablesContainer = document.getElementById('db-tables-container');
        const dbIngestBtn = document.getElementById('db-ingest-btn');

        let currentConfig = null;
        let globalResourceMap = {}; // Track name -> full path/url
        let lastUserQuestion = "";
        let lastBotResponse = "";

        providerSelect.onchange = async () => {
            const provider = providerSelect.value;
            localSettings.style.display = (provider === 'ollama' || provider === 'vllm') ? 'block' : 'none';
            cloudSettings.style.display = (provider === 'openai' || provider === 'gemini') ? 'block' : 'none';
            vllmUrlGroup.style.display = provider === 'vllm' ? 'block' : 'none';

            // Show/hide specific cloud groups
            document.getElementById('openai-key-group').style.display = provider === 'openai' ? 'block' : 'none';
            document.getElementById('openai-url-group').style.display = provider === 'openai' ? 'block' : 'none';
            document.getElementById('gemini-key-group').style.display = provider === 'gemini' ? 'block' : 'none';

            if (provider === 'ollama' || provider === 'vllm' || provider === 'openai' || provider === 'gemini') {
                modelHint.innerText = `Select the ${provider} model for chat generation.`;
                await loadModels(provider, null, modelSelect);
            }
        };

        embeddingProviderSelect.onchange = async () => {
            const provider = embeddingProviderSelect.value;
            if (provider === 'ollama' || provider === 'vllm') {
                const baseUrl = provider === 'vllm' ? vllmUrlInput.value : null;
                await loadModels(provider, baseUrl, embeddingModelSelect);

                if (currentConfig && provider === currentConfig.embedding_provider) {
                    embeddingModelSelect.value = (provider === 'ollama') ? currentConfig.ollama.embedding_model : currentConfig.vllm.embedding_model;
                }
            }
        };

        // Debounced model loading for URL change
        let vllmUrlTimeout;
        vllmUrlInput.oninput = () => {
            clearTimeout(vllmUrlTimeout);
            vllmUrlTimeout = setTimeout(() => {
                if (providerSelect.value === 'vllm') loadModels('vllm', vllmUrlInput.value, modelSelect);
                if (embeddingProviderSelect.value === 'vllm') loadModels('vllm', vllmUrlInput.value, embeddingModelSelect);
            }, 800);
        };

        async function loadCurrentConfig() {
            try {
                const response = await fetch(`${API_BASE}/config/current`);
                currentConfig = await response.json();

                providerSelect.value = currentConfig.provider;
                embeddingProviderSelect.value = currentConfig.embedding_provider || currentConfig.provider;

                if (currentConfig.vllm) vllmUrlInput.value = currentConfig.vllm.base_url || '';
                if (currentConfig.openai) {
                    openaiApiKeyInput.value = currentConfig.openai.api_key || '';
                    openaiBaseUrlInput.value = currentConfig.openai.base_url || 'https://api.openai.com/v1';
                }
                if (currentConfig.gemini) geminiApiKeyInput.value = currentConfig.gemini.api_key || '';

                await providerSelect.onchange();
                await embeddingProviderSelect.onchange();
            } catch (error) {
                console.error('Failed to load current config:', error);
            }
        }

        async function loadModels(provider, baseUrl = null, targetSelect) {
            if (!provider) provider = providerSelect.value;

            let url = `${API_BASE}/models/${provider}`;
            const params = new URLSearchParams();

            if (provider === 'vllm' && (baseUrl || vllmUrlInput.value)) params.append('base_url', baseUrl || vllmUrlInput.value);
            if (provider === 'openai') {
                if (openaiApiKeyInput.value) params.append('api_key', openaiApiKeyInput.value);
                if (openaiBaseUrlInput.value) params.append('base_url', openaiBaseUrlInput.value);
            }
            if (provider === 'gemini' && geminiApiKeyInput.value) params.append('api_key', geminiApiKeyInput.value);

            const queryString = params.toString();
            if (queryString) url += `?${queryString}`;

            targetSelect.innerHTML = '<option value="" disabled selected>Loading models...</option>';

            try {
                const response = await fetch(url);
                const data = await response.json();

                targetSelect.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.text = model;
                        targetSelect.appendChild(option);
                    });
                } else {
                    targetSelect.innerHTML = '<option value="">No models found</option>';
                }
            } catch (error) {
                console.error('Failed to load models:', error);
                targetSelect.innerHTML = '<option value="">Error connecting</option>';
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            const toastMsg = document.getElementById('toast-message');
            toastMsg.innerText = message;
            toast.classList.add('show');
            if (isError) {
                toast.style.borderLeft = '4px solid #f43f5e';
                toast.querySelector('i').className = 'fas fa-exclamation-circle';
                toast.querySelector('i').style.color = '#f43f5e';
            } else {
                toast.style.borderLeft = '4px solid #10b981';
                toast.querySelector('i').className = 'fas fa-check-circle';
                toast.querySelector('i').style.color = '#10b981';
            }
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        saveSettings.onclick = async () => {
            const provider = providerSelect.value;
            const embedProvider = embeddingProviderSelect.value;
            const updates = {
                "LLM_PROVIDER": provider,
                "EMBEDDING_PROVIDER": embedProvider
            };

            if (provider === 'ollama' || provider === 'vllm') {
                updates[provider === 'ollama' ? "OLLAMA_LLM_MODEL" : "VLLM_MODEL"] = modelSelect.value;
            }

            if (embedProvider === 'ollama' || embedProvider === 'vllm') {
                updates[embedProvider === 'ollama' ? "OLLAMA_EMBEDDING_MODEL" : "VLLM_EMBEDDING_MODEL"] = embeddingModelSelect.value;
            }

            if (provider === 'vllm' || embedProvider === 'vllm') {
                updates["VLLM_BASE_URL"] = vllmUrlInput.value;
            }

            if (provider === 'openai') {
                updates["OPENAI_API_KEY"] = openaiApiKeyInput.value;
                updates["OPENAI_BASE_URL"] = openaiBaseUrlInput.value;
                updates["OPENAI_LLM_MODEL"] = modelSelect.value;
            }

            if (provider === 'gemini') {
                updates["GEMINI_API_KEY"] = geminiApiKeyInput.value;
                updates["GEMINI_MODEL"] = modelSelect.value;
            }

            saveSettings.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
            saveSettings.disabled = true;

            try {
                const response = await fetch(`${API_BASE}/config/update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });

                if (response.ok) {
                    showToast(`Settings updated successfully`);
                } else {
                    throw new Error('Failed to update');
                }
            } catch (error) {
                showToast('Failed to update settings', true);
            } finally {
                saveSettings.innerText = 'Save Changes';
                saveSettings.disabled = false;
            }
        }
        // ==========================================
        // UI & NAVIGATION LOGIC
        // ==========================================
        const dbBtn = document.getElementById('db-btn');
        const settingsBtnHeader = document.getElementById('settings-btn');

        if (dbBtn) dbBtn.onclick = () => switchView('view-manage');
        if (settingsBtnHeader) settingsBtnHeader.onclick = () => switchView('view-settings');

        // Initial config load
        loadCurrentConfig();

        // File Selection Logic
        browseBtn.addEventListener('click', (e) => {
            e.preventDefault();
            fileInput.click();
        });

        uploadZone.addEventListener('click', (e) => {
            if (e.target !== browseBtn) fileInput.click();
        });

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.style.borderColor = 'var(--accent-color)';
        });

        uploadZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadZone.style.borderColor = 'var(--border-color)';
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.style.borderColor = 'var(--border-color)';
            if (e.dataTransfer.files.length) {
                handleFileSelect(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (fileInput.files.length) {
                handleFileSelect(fileInput.files[0]);
            }
        });

        let selectedFile = null;

        function handleFileSelect(file) {
            const allowedExtensions = ['.pdf', '.docx', '.txt', '.csv', '.md', '.xlsx', '.xls'];
            const fileName = file.name.toLowerCase();
            const isValid = allowedExtensions.some(ext => fileName.endsWith(ext));

            if (!isValid) {
                alert('Unsupported file type. Please upload PDF, Word, Text, CSV, or Excel files.');
                return;
            }
            selectedFile = file;
            fileNameDisplay.textContent = `Selected: ${file.name}`;
            uploadBtn.disabled = false;
        }

        // Upload Logic
        uploadBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            const formData = new FormData();
            formData.append('file', selectedFile);

            uploadBtn.disabled = true;
            uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';

            try {
                const response = await fetch(`${API_BASE}/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    alert('File uploaded successfully!');
                    fileNameDisplay.textContent = '';
                    selectedFile = null;
                    logToConsole(`UPLOAD SUCCESS: ${data.message}`, 'success');
                } else {
                    throw new Error('Upload failed');
                }
            } catch (error) {
                alert('Error uploading file');
                logToConsole(`UPLOAD ERROR: ${error.message}`, 'error');
            } finally {
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Upload File';
            }
        });

        // Console Logging Helper
        function logToConsole(message, type = 'info', targetId = 'console-output') {
            const container = document.getElementById(targetId) || consoleOutput;
            const line = document.createElement('span');
            line.className = `log-line ${type}`;
            line.textContent = `> ${message}`;
            container.appendChild(line);
            container.scrollTop = container.scrollHeight;

            // Also log to main management console if it's not the target
            if (targetId !== 'console-output') {
                const mainLine = line.cloneNode(true);
                consoleOutput.appendChild(mainLine);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        }

        // Streaming Logic
        async function startIngestionStream(fresh = false) {
            const url = `${API_BASE}/ingest/document/stream${fresh ? '?fresh=true' : ''}`;

            streamBtn.disabled = true;
            freshStreamBtn.disabled = true;
            logToConsole(fresh ? 'Starting FRESH build...' : 'Starting SYNC...', 'system');

            try {
                const response = await fetch(url);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    lines.forEach(line => {
                        if (line.trim()) {
                            // Check for error keywords
                            let type = 'info';
                            if (line.includes('ERROR') || line.includes('failed')) type = 'error';
                            if (line.includes('SUCCESS') || line.includes('saved')) type = 'success';
                            if (line.includes('WARNING')) type = 'warning';

                            logToConsole(line, type, 'pdf-console');
                        }
                    });
                }
                logToConsole('Process finished.', 'system', 'pdf-console');

            } catch (error) {
                logToConsole(`STREAM ERROR: ${error.message}`, 'error');
            } finally {
                streamBtn.disabled = false;
                freshStreamBtn.disabled = false;
            }
        }

        streamBtn.addEventListener('click', () => startIngestionStream(false));
        freshStreamBtn.addEventListener('click', () => startIngestionStream(true));

        // Initial load
        loadResources();

        // Initialize Chat Controls
        setupInputheightAdjust();
        setupVoiceInput();

        // ---------------------------------------------------------
        // UI HELPERS
        // ---------------------------------------------------------
        function setupInputheightAdjust() {
            const textarea = document.getElementById('user-input');
            if (!textarea) return;

            const adjustHeight = () => {
                textarea.style.height = 'auto'; // Reset height
                textarea.style.height = Math.min(textarea.scrollHeight, 150) + 'px'; // Set new height, max 150px
            };

            textarea.addEventListener('input', adjustHeight);

            // Also adjust on window resize
            window.addEventListener('resize', adjustHeight);
        }

        // ---------------------------------------------------------
        // VOICE INPUT LOGIC
        // ---------------------------------------------------------
        function setupVoiceInput() {
            const micBtn = document.getElementById('mic-btn');
            const langSelect = document.getElementById('voice-lang-select');
            const userInput = document.getElementById('user-input');

            // Check browser support
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (!SpeechRecognition) {
                if (micBtn) micBtn.style.display = 'none';
                if (langSelect) langSelect.style.display = 'none';
                console.warn('Web Speech API not supported in this browser.');
                return;
            }

            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;

            // Set initial language logic
            // Set initial language logic
            const setLang = () => {
                if (!langSelect) {
                    recognition.lang = ''; // Default to auto/browser default
                    return;
                }
                const lang = langSelect.value;
                if (lang === 'auto') {
                    recognition.lang = '';
                } else {
                    recognition.lang = lang;
                }
            };
            setLang(); // Safe to call now

            let isRecording = false;

            // Toggle Recording logic
            if (micBtn) {
                micBtn.addEventListener('click', () => {
                    if (isRecording) {
                        recognition.stop();
                    } else {
                        setLang();
                        try {
                            recognition.start();
                        } catch (e) {
                            console.error('Recognition start error:', e);
                        }
                    }
                });
            }

            // Update language dynamically only if selector exists
            if (langSelect) {
                langSelect.addEventListener('change', (e) => {
                    setLang();
                    if (isRecording) {
                        recognition.stop();
                    }
                });
            }

            // Events
            recognition.onstart = () => {
                isRecording = true;
                micBtn.classList.add('recording');
                micBtn.innerHTML = '<i class="fas fa-stop"></i>';
            };

            recognition.onend = () => {
                isRecording = false;
                micBtn.classList.remove('recording');
                micBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;

                // Append text
                const currentText = userInput.value;
                userInput.value = currentText ? `${currentText} ${transcript}` : transcript;

                // Trigger input event
                userInput.dispatchEvent(new Event('input'));
                userInput.focus();
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                isRecording = false;
                micBtn.classList.remove('recording');
                micBtn.innerHTML = '<i class="fas fa-microphone"></i>';

                if (event.error === 'not-allowed') {
                    alert('Microphone access denied. Please allow microphone permissions.');
                }
            };
        }

        async function loadResources() {
            const container = document.getElementById('resource-list-container');
            try {
                const response = await fetch(`${API_BASE}/resources`);
                const data = await response.json();

                container.innerHTML = '';

                const sections = [
                    { title: 'ðŸ“‘ Documents', key: 'documents', type: 'documents' },
                    { title: 'ðŸŒ Websites', key: 'websites', type: 'websites' },
                    { title: 'ðŸ“ DB Tables', key: 'databases', type: 'databases' }
                ];

                let totalItems = 0;
                sections.forEach(sec => {
                    if (data[sec.key] && data[sec.key].length > 0) {
                        const secDiv = document.createElement('div');
                        secDiv.className = 'res-section';
                        secDiv.innerHTML = `<h4>${sec.title}</h4>`;

                        data[sec.key].forEach(item => {
                            totalItems++;

                            // Map resource for preview/open logic
                            // For websites we use the item as URL, for docs we assume name match
                            if (sec.type === 'websites') globalResourceMap[item] = item;
                            else if (sec.type === 'documents') globalResourceMap[item] = `${API_BASE}/files/${item}`;
                            else if (sec.type === 'databases') globalResourceMap[`Table: ${item}`] = `Table: ${item}`;

                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'res-item';
                            const name = item;
                            const isDoc = sec.type === 'documents';
                            itemDiv.innerHTML = `
                                    <div class="res-info">
                                        <i class="fas ${isDoc ? 'fa-file-alt' : (sec.type === 'websites' ? 'fa-globe' : 'fa-table')}"></i>
                                        <span>${name}</span>
                                    </div>
                                    <div class="res-actions">
                                        ${isDoc ? `<a href="${API_BASE}/files/${name}" target="_blank" class="view-res-btn" title="View Document"><i class="fas fa-external-link-alt"></i></a>` : ''}
                                        <button onclick="deleteResource('${sec.type}', '${item}')" class="delete-res-btn" title="Remove Archive">
                                            <i class="fas fa-trash-alt"></i>
                                        </button>
                                    </div>
                                `;
                            secDiv.appendChild(itemDiv);
                        });
                        container.appendChild(secDiv);
                    }
                });

                if (totalItems === 0) {
                    container.innerHTML = '<p class="hint">No resources ingested yet.</p>';
                }

                // After loading resources, check health if we are in management view
                loadIndexHealth(data);

            } catch (error) {
                container.innerHTML = '<p class="hint error">Failed to load resources.</p>';
            }
        }

        async function loadIndexHealth(resourceData) {
            const list = document.getElementById('health-list');
            const totalDocsEl = document.getElementById('health-total-docs');
            const totalChunksEl = document.getElementById('health-total-chunks');

            try {
                console.log("Fetching index stats...");
                const response = await fetch(`${API_BASE}/index/stats`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const indexData = await response.json();
                console.log("Index statistics received:", indexData);

                totalDocsEl.textContent = indexData.total_documents;
                totalChunksEl.textContent = indexData.total_chunks;

                list.innerHTML = '';

                // Combine all resources into a set for lookup
                const allResources = new Set();
                if (resourceData) {
                    if (resourceData.documents) resourceData.documents.forEach(r => allResources.add(r));
                    if (resourceData.websites) resourceData.websites.forEach(r => allResources.add(r));
                    if (resourceData.databases) resourceData.databases.forEach(r => allResources.add(`Table: ${r}`));
                }

                const indexedSources = indexData.sources || {};
                const allKeys = new Set([...allResources, ...Object.keys(indexedSources)]);

                let hasMissing = false;

                allKeys.forEach(name => {
                    const isIndexed = indexedSources.hasOwnProperty(name);
                    const isResource = allResources.has(name);

                    // Logic to handle "Table: Name" matching if needed, but strict string match first

                    let status = 'ok';
                    let statusIcon = 'fa-check-circle';
                    let statusClass = 'status-ok';
                    let chunks = indexedSources[name] || 0;

                    if (isIndexed && isResource) {
                        // Healthy
                    } else if (isResource && !isIndexed) {
                        status = 'Missing from Index';
                        statusIcon = 'fa-exclamation-circle';
                        statusClass = 'status-missing';
                        hasMissing = true;
                    } else if (!isResource && isIndexed) {
                        status = 'Orphaned (Index only)';
                        statusIcon = 'fa-ghost';
                        statusClass = 'status-orphan';
                    }

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'health-item ' + statusClass;
                    itemDiv.innerHTML = `
                        <span class="health-name" title="${name}">${name}</span>
                        <span class="health-status"><i class="fas ${statusIcon}"></i> ${status}</span>
                        <div class="health-actions" style="display:flex; align-items:center;">
                            ${isIndexed ? `<button onclick="previewIndexSource('${name}')" class="preview-btn" title="Preview Content"><i class="fas fa-eye"></i></button>` : ''}
                            <span class="health-chunks">${chunks} chunks</span>
                        </div>
                    `;
                    list.appendChild(itemDiv);
                });

                const syncBtn = document.getElementById('sync-btn');
                if (hasMissing) {
                    syncBtn.style.display = 'inline-flex';
                    syncBtn.onclick = () => performSync();
                } else {
                    syncBtn.style.display = 'none';
                }

            } catch (error) {
                console.error("Health check failed", error);
                list.innerHTML = '<p class="hint error">Failed to load index stats.</p>';
            }
        }

        async function previewIndexSource(sourceName, usedDocs = []) {
            let previewModal = document.getElementById('preview-modal');
            if (!previewModal) {
                previewModal = document.createElement('div');
                previewModal.id = 'preview-modal';
                previewModal.className = 'modal-overlay';
                previewModal.style.display = 'none';
                previewModal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px; width: 95%;">
                        <div class="modal-header">
                            <div>
                                <h3 id="preview-modal-title" style="margin-bottom: 4px; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-database" style="-webkit-text-fill-color: var(--primary); font-size: 1.2rem;"></i> 
                                    <span>Index Content</span>
                                </h3>
                                <p id="preview-subtitle" style="font-size: 0.85rem; color: var(--text-muted); margin:0;">0 chunks loaded</p>
                            </div>
                            <button class="close-modal" onclick="document.getElementById('preview-modal').style.display='none'"><i class="fas fa-times"></i></button>
                        </div>
                        <div class="modal-body">
                            <input type="text" id="preview-search" class="modal-search-bar" placeholder="Search chunks...">
                            <div id="preview-content-loader" class="hint">Loading entire index for file...</div>
                            <div id="preview-chunks" class="content-chunks-container"></div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 20px 32px;">
                            <div id="preview-actions-left">
                                <!-- Dynamic Open button -->
                            </div>
                            <button class="action-btn secondary-btn" onclick="document.getElementById('preview-modal').style.display='none'">Close Window</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(previewModal);

                // Add search listener
                const searchInput = document.getElementById('preview-search');
                searchInput.addEventListener('input', (e) => {
                    const term = e.target.value.toLowerCase();
                    const cards = document.querySelectorAll('.chunk-card');
                    let visibleCount = 0;
                    cards.forEach(card => {
                        const text = card.innerText.toLowerCase();
                        if (text.includes(term)) {
                            card.style.display = 'block';
                            visibleCount++;
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    document.getElementById('preview-subtitle').innerHTML = `${visibleCount} chunks visible (of ${cards.length} total)`;
                });
            }

            document.querySelector('#preview-modal-title span').textContent = sourceName;
            document.getElementById('preview-subtitle').textContent = "Loading...";
            document.getElementById('preview-chunks').innerHTML = '';
            document.getElementById('preview-content-loader').style.display = 'block';
            document.getElementById('preview-search').value = '';

            // Handle "Open Source" button
            const leftActions = document.getElementById('preview-actions-left');
            leftActions.innerHTML = '';
            const sourceUrl = globalResourceMap[sourceName];
            if (sourceUrl && sourceUrl.startsWith('http')) {
                const openBtn = document.createElement('button');
                openBtn.className = 'action-btn primary-btn';
                openBtn.style.padding = '8px 20px';
                openBtn.innerHTML = `<i class="fas fa-external-link-alt"></i> ${sourceUrl.includes('/files/') ? 'Open Document' : 'Open Website'}`;
                openBtn.onclick = () => window.open(sourceUrl, '_blank');
                leftActions.appendChild(openBtn);
            }

            previewModal.style.display = 'flex';

            try {
                // Now returns ALL chunks (limit removed on backend)
                const response = await fetch(`${API_BASE}/index/preview?source=${encodeURIComponent(sourceName)}`);
                const chunks = await response.json();

                document.getElementById('preview-content-loader').style.display = 'none';
                const container = document.getElementById('preview-chunks');
                const subtitle = document.getElementById('preview-subtitle');

                subtitle.textContent = `${chunks.length} chunks stored in index`;

                if (chunks.length === 0) {
                    container.innerHTML = '<p class="hint">No content found for this source inside the index.</p>';
                    return;
                }

                // Prepare set of used content for O(1) lookup
                // We'll use a simplified check or exact match
                const usedContents = new Set(usedDocs.filter(d => d.source === sourceName).map(d => d.content.trim()));

                let firstUsedChunk = null;

                // Render all chunks
                chunks.forEach((chunk, index) => {
                    const card = document.createElement('div');
                    card.className = 'chunk-card';

                    // Check if this chunk was used
                    // We check if the content maps to one of our used docs
                    if (usedContents.has(chunk.content.trim())) {
                        card.classList.add('chunk-used');
                        if (!firstUsedChunk) firstUsedChunk = card;
                    }

                    card.innerHTML = `
                        <div class="chunk-header">
                            <span>#${index + 1}</span>
                            <span class="chunk-badge">Page ${chunk.page}</span>
                        </div>
                        <div class="chunk-text">${chunk.content}</div>
                    `;
                    container.appendChild(card);
                });

                // Scroll to first used chunk
                if (firstUsedChunk) {
                    setTimeout(() => {
                        firstUsedChunk.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                }

            } catch (error) {
                document.getElementById('preview-content-loader').textContent = 'Failed to load content.';
                console.error(error);
            }
        }

        async function performSync() {
            const syncBtn = document.getElementById('sync-btn');
            syncBtn.disabled = true;
            syncBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Syncing...';

            try {
                // Determine if we need to sync files or websites. 
                // Currently backend sync only supports ingest_pdfs logic (local files).
                const response = await fetch(`${API_BASE}/index/sync`, { method: 'POST' });

                // We're expecting a stream or similiar.
                // For simplicity, we just notify "Started" and listen to log.
                // Better: consume stream like other ingestions.

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                logToConsole("Started Resource Sync...", "system");

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    lines.forEach(line => {
                        if (line.trim()) logToConsole(line, 'info');
                    });
                }

                showToast("Sync completed");
                loadResources(); // Reloads both resources and health

            } catch (error) {
                showToast("Sync failed: " + error.message, true);
            } finally {
                syncBtn.disabled = false;
                syncBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Sync Missing';
            }
        }

        async function deleteResource(type, name) {
            if (!confirm(`Are you sure you want to remove "${name}"? This will delete the source file and associations.`)) return;

            try {
                const response = await fetch(`${API_BASE}/resources/${type}/${encodeURIComponent(name)}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                if (response.ok) {
                    showToast(result.message);
                    loadResources();
                } else {
                    throw new Error(result.detail || 'Delete failed');
                }
            } catch (error) {
                showToast(error.message, true);
            }
        }

        document.getElementById('reset-all-btn').onclick = async () => {
            if (!confirm("CRITICAL ACTION: This will delete ALL uploaded PDFs, clear the entire search index, and reset configurations. Proceed?")) return;

            try {
                const response = await fetch(`${API_BASE}/resources/reset`, { method: 'POST' });
                const result = await response.json();
                if (response.ok) {
                    showToast("System reset successfully");
                    loadResources();
                    logToConsole("SYSTEM RESET: All data wiped.", "warning");
                } else {
                    throw new Error('Reset failed');
                }
            } catch (error) {
                showToast(error.message, true);
            }
        };

        // Web Ingestion Logic

        async function startWebIngestionStream() {
            const url = webUrlInput.value.trim();
            if (!url) {
                alert('Please enter a URL first.');
                return;
            }

            const streamUrl = `${API_BASE}/ingest/web/stream?url=${encodeURIComponent(url)}`;
            webIngestBtn.disabled = true;
            logToConsole(`Starting WEB CRAWL for ${url}...`, 'system');

            try {
                const response = await fetch(streamUrl);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    lines.forEach(line => {
                        if (line.trim()) {
                            let type = 'info';
                            if (line.includes('ERROR') || line.includes('failed')) type = 'error';
                            if (line.includes('SUCCESS') || line.includes('saved')) type = 'success';
                            if (line.includes('WARNING')) type = 'warning';
                            logToConsole(line, type, 'web-console');
                        }
                    });
                }
                logToConsole('Web ingestion finished.', 'system', 'web-console');
            } catch (error) {
                logToConsole(`WEB STREAM ERROR: ${error.message}`, 'error');
            } finally {
                webIngestBtn.disabled = false;
            }
        }

        webIngestBtn.addEventListener('click', startWebIngestionStream);

        // SQL Database Ingestion Logic

        async function loadSchemas() {
            try {
                const response = await fetch(`${API_BASE}/db/schemas`);
                const data = await response.json();
                if (data.schemas) {
                    schemaSelect.innerHTML = '<option value="">Select Schema...</option>';
                    data.schemas.forEach(s => {
                        const opt = document.createElement('option');
                        opt.value = s;
                        opt.textContent = s;
                        schemaSelect.appendChild(opt);
                    });
                }
            } catch (error) {
                console.error('Failed to load schemas:', error);
            }
        }

        async function loadTables(schema) {
            if (!schema) {
                tablesContainer.innerHTML = '<p class="hint">Please select a schema to view tables.</p>';
                return;
            }
            tablesContainer.innerHTML = '<p class="hint">Loading tables...</p>';
            try {
                const url = `${API_BASE}/db/tables?schema=${encodeURIComponent(schema)}`;
                const response = await fetch(url);
                const data = await response.json();
                if (data.tables) {
                    // Render Professional List Structure
                    tablesContainer.innerHTML = `
                        <div class="sql-table-container">
                            <!-- Toolbar -->
                            <div class="sql-toolbar">
                                <div class="search-box">
                                    <i class="fas fa-search"></i>
                                    <input type="text" id="table-search" placeholder="Search tables...">
                                </div>
                                <div class="bulk-actions">
                                    <label class="action-checkbox">
                                        <input type="checkbox" id="select-all-tables" checked>
                                        <span>Select All</span>
                                    </label>
                                </div>
                            </div>

                            <!-- List Header -->
                            <div class="sql-list-header">
                                <div class="col-check"></div>
                                <div class="col-name">Table Name</div>
                            </div>

                            <!-- Scrollable List Body -->
                            <div class="sql-list-body" id="sql-list-body">
                                <!-- Rows will be injected here -->
                            </div>

                            <!-- Footer -->
                            <div class="sql-footer">
                                <span class="selection-summary" id="selection-summary">0 tables selected</span>
                                <!-- Button moved here dynamically if needed, or kept outside -->
                            </div>
                        </div>
                    `;

                    const listBody = tablesContainer.querySelector('#sql-list-body');
                    const selectAllCheckbox = tablesContainer.querySelector('#select-all-tables');
                    const searchInput = tablesContainer.querySelector('#table-search');
                    const summaryText = tablesContainer.querySelector('#selection-summary');

                    // Helper to update selection stats
                    function updateSelectionStats() {
                        const total = listBody.querySelectorAll('input[type="checkbox"]').length;
                        const checked = listBody.querySelectorAll('input[type="checkbox"]:checked').length;
                        summaryText.textContent = `${checked} of ${total} tables selected`;

                        // Update Select All state
                        const allChecked = total > 0 && total === checked;
                        selectAllCheckbox.checked = allChecked;
                        selectAllCheckbox.indeterminate = !allChecked && checked > 0;
                    }

                    data.tables.forEach(table => {
                        const row = document.createElement('div');
                        row.className = 'sql-row';
                        row.innerHTML = `
                            <div class="col-check">
                                <input type="checkbox" value="${table}" checked>
                            </div>
                            <div class="col-name" title="${table}">${table}</div>
                        `;

                        // Row click toggles checkbox
                        row.addEventListener('click', (e) => {
                            if (e.target.type !== 'checkbox') {
                                const cb = row.querySelector('input[type="checkbox"]');
                                cb.checked = !cb.checked;
                                // Trigger change event manually if needed, or just update stats
                                updateSelectionStats();
                            }
                        });

                        // Checkbox change updates stats
                        row.querySelector('input').addEventListener('change', updateSelectionStats);

                        listBody.appendChild(row);
                    });

                    // Initial stats update
                    updateSelectionStats();

                    // Search Logic
                    searchInput.addEventListener('input', (e) => {
                        const term = e.target.value.toLowerCase();
                        listBody.querySelectorAll('.sql-row').forEach(row => {
                            const name = row.querySelector('.col-name').textContent.toLowerCase();
                            row.style.display = name.includes(term) ? 'grid' : 'none';
                        });
                    });

                    // Select All Logic
                    selectAllCheckbox.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        const rows = listBody.querySelectorAll('.sql-row');

                        rows.forEach(row => {
                            if (row.style.display !== 'none') {
                                row.querySelector('input').checked = isChecked;
                            }
                        });
                        updateSelectionStats();
                    });
                }
            } catch (error) {
                tablesContainer.innerHTML = `<p class="hint error">Error loading tables: ${error.message}</p>`;
            }
        }

        schemaSelect.addEventListener('change', (e) => loadTables(e.target.value));

        async function startDbIngestionStream() {
            const selectedTables = Array.from(tablesContainer.querySelectorAll('input:checked'))
                .map(cb => cb.value);

            if (selectedTables.length === 0) {
                alert('Please select at least one table.');
                return;
            }

            const schema = schemaSelect.value;
            let streamUrl = `${API_BASE}/ingest/db/stream?tables=${selectedTables.join(',')}`;
            if (schema) streamUrl += `&schema=${encodeURIComponent(schema)}`;

            dbIngestBtn.disabled = true;
            logToConsole(`Starting DATABASE INGESTION for ${selectedTables.length} tables...`, 'system');

            try {
                const response = await fetch(streamUrl);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    lines.forEach(line => {
                        if (line.trim()) {
                            let type = 'info';
                            if (line.includes('ERROR') || line.includes('SKIP')) type = 'error';
                            if (line.includes('SUCCESS') || line.includes('Added')) type = 'success';
                            if (line.includes('WARNING')) type = 'warning';
                            logToConsole(line, type, 'db-console');
                        }
                    });
                }
                logToConsole('Database ingestion finished.', 'system', 'db-console');
            } catch (error) {
                logToConsole(`DB STREAM ERROR: ${error.message}`, 'error');
            } finally {
                dbIngestBtn.disabled = false;
            }
        }

        dbIngestBtn.addEventListener('click', startDbIngestionStream);

        // Mobile Sidebar Toggle Logic
        const menuToggle = document.getElementById('menu-toggle');
        const closeSidebar = document.getElementById('close-sidebar');
        const sidebar = document.querySelector('.sidebar');

        menuToggle.onclick = () => {
            sidebar.classList.add('mobile-active');
        };

        closeSidebar.onclick = () => {
            sidebar.classList.remove('mobile-active');
        };

        // Close sidebar when clicking a nav item on mobile
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', () => {
                sidebar.classList.remove('mobile-active');
            });
        });

        // Update window click handler to close both modals AND sidebar
        // Modal backdrop logic removed
        window.onclick = (event) => {
            if (event.target == sidebar && sidebar.classList.contains('mobile-active')) {
                sidebar.classList.remove('mobile-active');
            }
        }
    </script>
</body>

</html>